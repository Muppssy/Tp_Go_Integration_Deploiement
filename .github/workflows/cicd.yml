name: Build the app docker image

on:
  push

jobs:

  # 1) Tests unitaires (lance en parallèle de "versioning")
  test-unitaire:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true
      - name: Run unit tests (exclude integration)
        run: |
          PKGS=$(go list ./... | grep -v '/test/apitests$' || true)
          if [ -n "$PKGS" ]; then
            go test -count=1 -v $PKGS
          else
            echo "No unit-test packages to run."
          fi

  # 2) Versioning (en parallèle de "test-unitaire")
  versioning:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.versioning.outputs.version }}
      imageName: ${{ steps.versioning.outputs.imageName }}
    steps:
      - uses: actions/checkout@v4
      - name: Compute versions
        id: versioning
        shell: bash
        run: |
          set -euo pipefail
          version=$(git rev-parse --short HEAD)
          repo_lc=$(echo "$GITHUB_REPOSITORY" | tr '[:upper:]' '[:lower:]')   # GHCR = lowercase
          imageName="ghcr.io/${repo_lc}:${version}"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "imageName=$imageName" >> "$GITHUB_OUTPUT"
          echo "## 🔖 New version '$version'" >> "$GITHUB_STEP_SUMMARY"
          echo "## 📦 Image '$imageName'" >> "$GITHUB_STEP_SUMMARY"

  # 3) Build & Push (ne démarre que si versioning **et** tests OK)
  build-and-push:
    runs-on: ubuntu-latest
    needs: [versioning, test-unitaire]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        run: echo "${{secrets.GITHUB_TOKEN}}" | docker login ghcr.io -u "${{github.actor}}" --password-stdin
      - name: Build image
        run: docker build -t "${{ needs.versioning.outputs.imageName }}" .
      - name: Push image
        run: docker push "${{ needs.versioning.outputs.imageName }}"

  # 4) (Optionnel) Tests d'API après le push
  api-tests:
    runs-on: ubuntu-latest
    needs: [build-and-push, versioning]
    permissions:
      contents: read
      packages: read
    services:
      backend:
        image: ${{ needs.versioning.outputs.imageName }}
        credentials:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        ports:
          - "8080:8080"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true
      - name: Wait for API (probe /api/cats or /cats)
        shell: bash
        run: |
          for i in {1..30}; do
            for p in /api/cats /cats; do
              code=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:8080${p}" || true)
              [ "$code" = "200" ] && exit 0
            done
            sleep 2
          done
          echo "API never replied 200"; exit 1
      - name: Run integration tests
        run: |
          if [ -d "./test/apitests" ]; then
            go test -count=1 -v ./test/apitests
            else
              echo "No ./test/apitests package; skipping."
            fi

  deployed:
      runs-on: ubuntu-latest
      needs: [build-and-push, versioning]  
      # attend le push & la version
      if: ${{ github.ref_name != 'versions-branch' }}   # éviter la boucle quand on push sur cette branche
      permissions:
        contents: write
      env:
        VERSION_BRANCH: versions-branch     # ← mets ici le vrai nom de ta branche orpheline
      steps:
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create/switch to version branch and update version.txt
        shell: bash
        run: |
          set -euo pipefail
          BR="${VERSION_BRANCH}"
          VER="${{ needs.versioning.outputs.version }}"

          # S'assure d'avoir les refs distantes
          git fetch origin +refs/heads/*:refs/remotes/origin/* --prune

          if git show-ref --verify --quiet "refs/remotes/origin/${BR}"; then
            echo "Branch '${BR}' exists on remote. Switching..."
            # créer une branche locale à partir de la distante (ou la mettre à jour si elle existe déjà)
            git switch -c "${BR}" "origin/${BR}" 2>/dev/null || git switch "${BR}"
            git merge --ff-only "origin/${BR}" || true
          else
            echo "Branch '${BR}' does not exist. Creating orphan branch..."
            git switch --orphan "${BR}"
            # Nettoyer le workspace (tout sauf .git)
            git ls-files -z | xargs -0 --no-run-if-empty git rm -f -q || true
            git clean -fdx -e .git || true
          fi

          # Écrit la version
          printf "%s\n" "$VER" > version.txt
          git add version.txt
          git -c user.name="${{ github.actor }}" \
              -c user.email="${{ github.actor }}@users.noreply.github.com" \
              commit -m "chore(deploy): set version to ${VER}" || echo "No changes to commit"

          # Push sur la branche de version
          git push origin HEAD:"${BR}"
